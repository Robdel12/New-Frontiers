---
layout: post
title: "Your tests aren’t slow because of Karma (or the browser)"
date: 2019-06-21 04:28:56 UTC
excerpt: " There’s been a trend I have been seeing around the front end world where folks are switching their test suites to use Jest over something like Karma and Mocha. Usually the main benefit that’s touted is speed&nbsp;🏎💨  What..."
---

 <p>There’s been a trend I have been seeing around the front end world where folks are switching their test suites to use Jest over something like Karma and Mocha. Usually the main benefit that’s touted is speed 🏎💨</p><p>What’s not commonly talked about is the the trade-off you’re making here — you’re no longer testing in an environment any users actually use. You can’t test in Safari, Chrome, Edge, or Firefox anymore. You’re running your tests in JSDOM, which is an implementation of the DOM spec. I don’t see this being any better than something like PhantomJS (RIP in peace). Cross browser bugs exist, and the DOM is not just an implementation detail.</p><p>Don’t get me wrong, Jest is a <em>really</em> nice test runner. There’s a whole lot to love about it. Which is why I have a vested interest in getting it to run inside of a real browser. But the speed boost you get from running your tests in the JSDOM is not worth the trade-off you’re making, imo.</p><h3>Best of both worlds</h3><p>It’s totally possible to have <em>blazing</em> fast component unit tests that fully mount into the DOM inside of a real browser. How fast? How about <strong>661 tests that complete in 17 seconds</strong>? <a href="https://jenkins-aws.indexdata.com/blue/organizations/jenkins/folio-org%2Fstripes-components/detail/master/815/pipeline/67/">Here’s your proof</a>. With compiling everything and launching the browser the total time is <strong>51 seconds</strong>. <a href="https://github.com/folio-org/stripes-components">Here’s the source of the repo</a> that those tests are coming from.</p><h4>How?</h4><p>Karma isn’t slow. The real DOM isn’t slow as you think it is. It’s probably the tools you picked to help write those tests. The example I mentioned above that runs so fast uses a package called <a href="https://interactorjs.io">Interactor.js</a>. Interactor.js is a composable, immutable, asynchronous way to interact with components or applications like a user would. From the introduction in the docs:</p><blockquote>Interactors work anywhere there is DOM, and run alongside your tests to produce blazingly fast results. They automatically wait for elements to exist in the DOM before interacting with them and also provide a simple interface for making asynchronous assertions against the DOM as well.</blockquote><p>Not only are those tests extremely fast with Interactor.js, it carries many benefits with no trade offs like JSDOM does (and is <em>faster</em>). You’re testing in real browser<strong>s</strong> while actually interacting with the DOM like a user would in real life.</p><p>Combine Interactor.js with something like <a href="https://github.com/wwilsman/testing-hooks">testing-hooks</a> or <a href="https://github.com/testing-library/dom-testing-library">dom-testing-library</a> to mount the components into the DOM and you have a seriously powerful combo! Imagine this example that completes in less than a second:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ad7de3959f25b90eced8b01e5560c815/href">https://medium.com/media/ad7de3959f25b90eced8b01e5560c815/href</a></iframe><p>This is only scratching the surface of the possibilities that Interactor.js unlocks. I think it would be worth taking a look before moving your tests over to Jest (or JSDOM).</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dd4347296991" width="1" height="1" alt="">